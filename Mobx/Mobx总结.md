# Mobx总结

## Mobx要点

**使用Mobx将一个应用变为响应式：**

1. 定义状态并使其可观察  
可以用任何数据结构来存储状态，为属性标记上mobx标记使其**可观察**即可，通过observable修饰属性使其可观察。  
**Tips:** mobx可能无法检测到复杂结构数据深层次的变动，导致无法带动视图渲染。因此尽量使用简单结构，层次浅的数据。在必要时也可使用@map修饰你的数据，使其深层次可观察。这可能是你常见的数据变化却无法看到视图重新渲染的原因。

2. 创建视图以相应状态的变化  
创建视图，标记视图让其观察所依赖的可被观测的数据，当数据发生改变时，视图会自动更新。mobx以最小限度的改变更新视图。  
**observable:** 被观察者（数据模型）  
**observer:** 观察者(视图或任意函数)  
**Tips:** 当你具备数据驱动视图渲染的思维之后，便很容易能够理解和接受以数据为核心的驱动方案。视图骨架需要在数据血液的充盈下才能够焕发活力与生机，变得生动而形象。  

3. 更改状态  
更改状态，根据你的需要，变动你的数据模型。变动后的数据会反馈到视图上，重新渲染必要的部门。  
**Tips:** 在mobx中我们通过action来修饰数据控制器，尽量标准化你的代码，仅在acion中修改你的数据模型。

## API

**Observable**  
* 对象上只有初始化时便存在的属性会被观察到变化，创建**键是动态的对象**使用**Observable Map**。
* @observable key = value 同 extendObservable(this, { key: value })  

**computed**  
>计算值是可以根据现有的状态或其它计算值衍生出的值。无需常见新的observable变量来存储，类似于excel的公式。  
**Tips:** computed创建的函数只有当它有自己的观察者时才会重新计算。

**Autorun**
>autorun创建的响应式函数，**本身不会有观察者**。使用autorun时，函数立即被触发一次，**每次它的依赖数据改变时**会再次被触发。
